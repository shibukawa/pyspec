# -*- coding: ascii -*-

"""PySpec mock objects

This Module includes following objects.

1. MockObject

   This class can record method calls and replay
   unimplemented objects in your mind.

2. MockFile

   This class can record expected file contents.
   If you want to test any object that writes file,
   you can verify that's output.

3. MockSocket

   This class supports testing of the object which communicates
   with socket.
"""

__pyspec = 1
import pyspec3
from pyspec3.utils.dprint import dprint_for_lib


class MockResult(object):
    """This supports recording the result of method call.

    This objects are generated by MockMethod.

    @note: internal class
    """
    __slots__ = ("parent")
    def __init__(self, parent_method):
        self.parent = parent_method

    def result(self, result_value):
        """Passing expected return value to a mock method object."""
        self.parent.result_value = result_value

    def __eq__(self, result_value):
        """Passing expected return value to a mock method object."""
        self.parent.result_value = result_value
        return True


class MockMethod(object):
    """This class record method call and its result.

    This object can verify method's arguments.
    This objects are generated by MockObject.

    @note: internal class
    """
    __slots__ = ("name", "is_recording", "result_value",
                 "args", "kwargs")
    def __init__(self, name):
        self.name = name
        self.is_recording = True
        self.result_value = None
        self.args = []
        self.kwargs = {}

    def _call(self, name):
        """Verify method.

        It's called by MockObject.__getattribute__().
        It notify method name errors if method name is not match,.

        @raise AssertionError: if method name is not match.
        """
        self.is_recording = False
        if name != self.name:
            raise AssertionError("Mock: expected function name is %s(), but was %s()" % (self.name, name))
        return self

    def __call__(self, *args, **kwargs):
        """This is core method(recording and verifying) of this class.

        1. Record arguments and return MockResult object when recording.

        2. Verify arguments and return expected result value when replaying.
        """
        dprint_for_lib("  arg = %s" % str(args))
        dprint_for_lib("  kwargs = %s" % str(kwargs))
        if self.is_recording:
            self.args = args
            self.kwargs = kwargs
            return MockResult(self)
        else:
            if args != self.args:
                raise AssertionError("Mock: expected args are %r, but was %r" % (self.args, args))
            if kwargs != self.kwargs:
                raise AssertionError("Mock: expected kwargs are %r, but was %r" % (self.kwargs, kwargs))
            return self.result_value

    def __str__(self):
        args = ", ".join((repr(arg) for arg in self.args))
        kwargs = ", ".join(("%s=%s" % (key, repr(value)) \
                 for key, value in sorted(self.kwargs.items())))
        if args != "" and kwargs != "":
            argstring = "%s, %s" % (args, kwargs)
        elif args != "":
            argstring = args
        else:
            argstring = kwargs

        return "%s(%s) == %r" % (self.name, argstring, self.result_value)


class MockObject(object):
    """

    @todo: recording class name.
    """
    def __init__(self, class_name = "*Mock*"):
        self._class_name = class_name
        self._is_recording = True
        self._records = []
        self._current = 0

    def __getattribute__(self, name):
        try:
            attr = super(MockObject, self).__getattribute__(name)
            return attr
        except AttributeError:
            if name in ("__members__", "__methods__"):
                raise AttributeError()
            if self._is_recording:
                self._records.append(MockMethod(name))
                dprint_for_lib("MockObject: %s() called." % name)
                return self._records[-1]
            else:
                dprint_for_lib("MockObject: %s() called." % name)
                if len(self._records) <= self._current:
                    raise AssertionError("Mock: unexpected method call '%s'" % name)
                result = self._records[self._current]
                self._current += 1
                return result._call(name)

    def end_record(self):
        self._is_recording = False
        dprint_for_lib("MockObject: expected calls")
        for method in self._records:
            dprint_for_lib("  %s()" % method.name)

    def verify(self):
        if len(self._records) != self._current:
            raise AssertionError("Mock: method %s() must be called." % self._records[self._current].name)
        msg = ["MockObject should be call like this:"]
        for record in self._records:
            msg.append(str(record))
        pyspec.report_out.write((None, "\n".join(msg)))


class MockFile(object):
    def __init__(self, contents):
        self.contents = contents
        self.cursor = 0

    def write(self, actual):
        length = len(actual)
        start = self.cursor
        end = length + self.cursor
        try:
            expected = self.contents[start:end]
        except IndexError:
            raise AssertionError("FileMock: last write('%s') is unexpected" % actual)
        if expected != actual:
            raise AssertionError("FileMock: expected is '%s', but was '%s'" % (expected, actual))
        self.cursor = end

    def verify(self):
        start = self.cursor
        remain = len(self.contents) - start
        if remain > 0:
            str = self.contents[start:start+7]
            if remain > 7:
                str = str + "..."
            raise AssertionError("FileMock: %d chars(%s) must be written." % (remain, str))


class MockSocket(object):
    def __init__(self, recv=None, send=None):
        self.send_messages = []
        self.recv_messages = []
        self.blocking = 1
        self.timeout = None

        if type(recv) == str:
            self.add_recv_message(recv)
        elif type(recv) in (list, tuple):
            self.add_recv_message(*recv)
        if type(send) == str:
            self.add_send_message(send)
        elif type(send) in (list, tuple):
            self.add_send_message(*send)

    def add_recv_message(self, *message):
        self.recv_messages = self.recv_messages + list(message)

    def add_send_message(self, *message):
        self.send_messages = self.send_messages + list(message)

    def recv(self, bufsize, flag=None):
        import socket, errno
        try:
            result = self.recv_messages[0]
            if len(result) > bufsize:
                self.recv_messages[0] = result[bufsize:]
                result = result[:bufsize]
            else:
                del self.recv_messages[0]
            return result
        except IndexError:
            if self.blocking == 1:
                raise AssertionError("recv buffer underflow")
            else:
                raise socket.error((errno.ETIMEDOUT, "timeout"))

    def send(self, string, flag=None):
        try:
            if self.send_messages[0] != string:
                raise AssertionError('MockSocket.send(): expected is "%s", but was "%s"' % (self.send_messages[0], string))
            del self.send_messages[0]
            return len(string)
        except IndexError:
            raise AssertionError('MockSocket.send(): unexpected send "%s"' % string)

    def accept(self):
        return (self, None)

    def setblocking(self, flag):
        if flag == 0:
            self.settimeout(0)
        else:
            self.settimeout(1)

    def settimeout(self, value):
        if value is None:
            self.blocking = 1
            self.settimeout = None
        else:
            self.blocking = 0
            self.timeout = float(value)

    def gettimeout(self):
        return self.timeout

    def __getattribute__(self, name):
        try:
            attr = super(MockSocket, self).__getattribute__(name)
            return attr
        except AttributeError:
            if name in ["accept", "bind", "close", "connect", "connect_ex",
                        "fileno", "getpeername", "getsockname", "getsockopt",
                        "listen", "makefile", "recvfrom", "sendall", "sendto",
                        "setsockopt", "shutdown"]:
                return MockMethod(name)
            raise AttributeError(name)
